// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

/**
 * Service provides cryptographic functions to the application.
 * It delegates to Enchantrix for all cryptographic operations.
 * @module
 */

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import { Call as $Call, CancellablePromise as $CancellablePromise, Create as $Create } from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as core$0 from "../core/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as io$0 from "../../../../../io/models.js";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as $models from "./models.js";

/**
 * Config returns the registered Config service from the core application.
 * This is a convenience method for accessing the application's configuration.
 */
export function Config(): $CancellablePromise<core$0.Config> {
    return $Call.ByID(4086601246);
}

/**
 * Core returns the central core instance, providing access to all registered services.
 */
export function Core(): $CancellablePromise<core$0.Core | null> {
    return $Call.ByID(81428095).then(($result: any) => {
        return $$createType1($result);
    });
}

/**
 * DecryptPGP decrypts a PGP message.
 * Note: Enchantrix does not support passphrase-protected keys for decryption.
 */
export function DecryptPGP(privateKey: string, message: string): $CancellablePromise<string> {
    return $Call.ByID(583706276, privateKey, message);
}

/**
 * DecryptRSA decrypts data using an RSA private key.
 * Takes PEM-encoded private key and ciphertext.
 */
export function DecryptRSA(privateKeyPEM: string, ciphertext: string): $CancellablePromise<string> {
    return $Call.ByID(1345539309, privateKeyPEM, ciphertext);
}

/**
 * EncryptPGP encrypts data for a recipient and writes to the provided writer.
 */
export function EncryptPGP(writer: io$0.Writer, recipientPublicKey: string, data: string): $CancellablePromise<void> {
    return $Call.ByID(2890283020, writer, recipientPublicKey, data);
}

/**
 * EncryptPGPToString encrypts data for a recipient and returns the ciphertext.
 */
export function EncryptPGPToString(recipientPublicKey: string, data: string): $CancellablePromise<string> {
    return $Call.ByID(165721080, recipientPublicKey, data);
}

/**
 * EncryptRSA encrypts data using an RSA public key.
 * Takes PEM-encoded public key and returns base64-encoded ciphertext.
 */
export function EncryptRSA(publicKeyPEM: string, plaintext: string): $CancellablePromise<string> {
    return $Call.ByID(2625148021, publicKeyPEM, plaintext);
}

/**
 * Fletcher16 computes the Fletcher-16 checksum.
 */
export function Fletcher16(payload: string): $CancellablePromise<number> {
    return $Call.ByID(1946934332, payload);
}

/**
 * Fletcher32 computes the Fletcher-32 checksum.
 */
export function Fletcher32(payload: string): $CancellablePromise<number> {
    return $Call.ByID(134657290, payload);
}

/**
 * Fletcher64 computes the Fletcher-64 checksum.
 */
export function Fletcher64(payload: string): $CancellablePromise<number> {
    return $Call.ByID(4160741397, payload);
}

/**
 * GeneratePGPKeyPair generates a PGP key pair.
 * Note: Enchantrix PGP keys are not passphrase-protected. The comment parameter
 * is used instead of passphrase for key metadata.
 */
export function GeneratePGPKeyPair(name: string, email: string, comment: string): $CancellablePromise<[string, string]> {
    return $Call.ByID(404306973, name, email, comment);
}

/**
 * GenerateRSAKeyPair generates an RSA key pair with the specified bit size.
 * Returns PEM-encoded public and private keys.
 */
export function GenerateRSAKeyPair(bits: number): $CancellablePromise<[string, string]> {
    return $Call.ByID(931266286, bits);
}

/**
 * HandleIPCEvents processes IPC messages for the crypt service.
 */
export function HandleIPCEvents(c: core$0.Core | null, msg: core$0.Message): $CancellablePromise<void> {
    return $Call.ByID(2172739989, c, msg);
}

/**
 * Hash computes a hash of the payload using the specified algorithm.
 */
export function Hash(lib: $models.HashType, payload: string): $CancellablePromise<string> {
    return $Call.ByID(2586228864, lib, payload);
}

/**
 * IsHashAlgo checks if the given string is a valid hash algorithm.
 */
export function IsHashAlgo(algo: string): $CancellablePromise<boolean> {
    return $Call.ByID(326857739, algo);
}

/**
 * Luhn validates a number using the Luhn algorithm.
 */
export function Luhn(payload: string): $CancellablePromise<boolean> {
    return $Call.ByID(2072043901, payload);
}

/**
 * SignPGP signs data with a PGP private key.
 */
export function SignPGP(privateKey: string, data: string): $CancellablePromise<string> {
    return $Call.ByID(1808182420, privateKey, data);
}

/**
 * SymmetricallyEncryptPGP encrypts data using a passphrase and writes to the provided writer.
 */
export function SymmetricallyEncryptPGP(writer: io$0.Writer, data: string, passphrase: string): $CancellablePromise<void> {
    return $Call.ByID(1965343785, writer, data, passphrase);
}

/**
 * VerifyPGP verifies a PGP signature.
 */
export function VerifyPGP(publicKey: string, data: string, signature: string): $CancellablePromise<void> {
    return $Call.ByID(2355577904, publicKey, data, signature);
}

// Private type creation functions
const $$createType0 = core$0.Core.createFrom;
const $$createType1 = $Create.Nullable($$createType0);
