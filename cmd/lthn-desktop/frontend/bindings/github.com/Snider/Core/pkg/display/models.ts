// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import { Create as $Create } from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as application$0 from "../../../../wailsapp/wails/v3/pkg/application/models.js";

/**
 * CreateWindowOptions contains options for creating a new window.
 */
export class CreateWindowOptions {
    "name": string;
    "title"?: string;
    "url"?: string;
    "x"?: number;
    "y"?: number;
    "width"?: number;
    "height"?: number;

    /** Creates a new CreateWindowOptions instance. */
    constructor($$source: Partial<CreateWindowOptions> = {}) {
        if (!("name" in $$source)) {
            this["name"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new CreateWindowOptions instance from a string or object.
     */
    static createFrom($$source: any = {}): CreateWindowOptions {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new CreateWindowOptions($$parsedSource as Partial<CreateWindowOptions>);
    }
}

/**
 * FileFilter represents a file type filter for dialogs.
 */
export class FileFilter {
    "displayName": string;
    "pattern": string;
    "extensions"?: string[];

    /** Creates a new FileFilter instance. */
    constructor($$source: Partial<FileFilter> = {}) {
        if (!("displayName" in $$source)) {
            this["displayName"] = "";
        }
        if (!("pattern" in $$source)) {
            this["pattern"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new FileFilter instance from a string or object.
     */
    static createFrom($$source: any = {}): FileFilter {
        const $$createField2_0 = $$createType0;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("extensions" in $$parsedSource) {
            $$parsedSource["extensions"] = $$createField2_0($$parsedSource["extensions"]);
        }
        return new FileFilter($$parsedSource as Partial<FileFilter>);
    }
}

/**
 * Layout represents a saved window arrangement.
 */
export class Layout {
    "name": string;
    "windows": { [_: string]: WindowState };
    "createdAt": number;
    "updatedAt": number;

    /** Creates a new Layout instance. */
    constructor($$source: Partial<Layout> = {}) {
        if (!("name" in $$source)) {
            this["name"] = "";
        }
        if (!("windows" in $$source)) {
            this["windows"] = {};
        }
        if (!("createdAt" in $$source)) {
            this["createdAt"] = 0;
        }
        if (!("updatedAt" in $$source)) {
            this["updatedAt"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Layout instance from a string or object.
     */
    static createFrom($$source: any = {}): Layout {
        const $$createField1_0 = $$createType2;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("windows" in $$parsedSource) {
            $$parsedSource["windows"] = $$createField1_0($$parsedSource["windows"]);
        }
        return new Layout($$parsedSource as Partial<Layout>);
    }
}

/**
 * LayoutInfo contains summary information about a layout.
 */
export class LayoutInfo {
    "name": string;
    "windowCount": number;
    "createdAt": number;
    "updatedAt": number;

    /** Creates a new LayoutInfo instance. */
    constructor($$source: Partial<LayoutInfo> = {}) {
        if (!("name" in $$source)) {
            this["name"] = "";
        }
        if (!("windowCount" in $$source)) {
            this["windowCount"] = 0;
        }
        if (!("createdAt" in $$source)) {
            this["createdAt"] = 0;
        }
        if (!("updatedAt" in $$source)) {
            this["updatedAt"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new LayoutInfo instance from a string or object.
     */
    static createFrom($$source: any = {}): LayoutInfo {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new LayoutInfo($$parsedSource as Partial<LayoutInfo>);
    }
}

/**
 * NotificationOptions contains options for showing a notification.
 */
export class NotificationOptions {
    "id"?: string;
    "title": string;
    "message": string;
    "subtitle"?: string;

    /** Creates a new NotificationOptions instance. */
    constructor($$source: Partial<NotificationOptions> = {}) {
        if (!("title" in $$source)) {
            this["title"] = "";
        }
        if (!("message" in $$source)) {
            this["message"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new NotificationOptions instance from a string or object.
     */
    static createFrom($$source: any = {}): NotificationOptions {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new NotificationOptions($$parsedSource as Partial<NotificationOptions>);
    }
}

/**
 * OpenDirectoryOptions contains options for the directory picker.
 */
export class OpenDirectoryOptions {
    "title"?: string;
    "defaultDirectory"?: string;
    "allowMultiple"?: boolean;

    /** Creates a new OpenDirectoryOptions instance. */
    constructor($$source: Partial<OpenDirectoryOptions> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new OpenDirectoryOptions instance from a string or object.
     */
    static createFrom($$source: any = {}): OpenDirectoryOptions {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new OpenDirectoryOptions($$parsedSource as Partial<OpenDirectoryOptions>);
    }
}

/**
 * OpenFileOptions contains options for the open file dialog.
 */
export class OpenFileOptions {
    "title"?: string;
    "defaultDirectory"?: string;
    "defaultFilename"?: string;
    "filters"?: FileFilter[];
    "allowMultiple"?: boolean;

    /** Creates a new OpenFileOptions instance. */
    constructor($$source: Partial<OpenFileOptions> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new OpenFileOptions instance from a string or object.
     */
    static createFrom($$source: any = {}): OpenFileOptions {
        const $$createField3_0 = $$createType4;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("filters" in $$parsedSource) {
            $$parsedSource["filters"] = $$createField3_0($$parsedSource["filters"]);
        }
        return new OpenFileOptions($$parsedSource as Partial<OpenFileOptions>);
    }
}

/**
 * SaveFileOptions contains options for the save file dialog.
 */
export class SaveFileOptions {
    "title"?: string;
    "defaultDirectory"?: string;
    "defaultFilename"?: string;
    "filters"?: FileFilter[];

    /** Creates a new SaveFileOptions instance. */
    constructor($$source: Partial<SaveFileOptions> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new SaveFileOptions instance from a string or object.
     */
    static createFrom($$source: any = {}): SaveFileOptions {
        const $$createField3_0 = $$createType4;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("filters" in $$parsedSource) {
            $$parsedSource["filters"] = $$createField3_0($$parsedSource["filters"]);
        }
        return new SaveFileOptions($$parsedSource as Partial<SaveFileOptions>);
    }
}

/**
 * ScreenInfo contains information about a display screen.
 */
export class ScreenInfo {
    "id": string;
    "name": string;
    "x": number;
    "y": number;
    "width": number;
    "height": number;
    "primary": boolean;

    /** Creates a new ScreenInfo instance. */
    constructor($$source: Partial<ScreenInfo> = {}) {
        if (!("id" in $$source)) {
            this["id"] = "";
        }
        if (!("name" in $$source)) {
            this["name"] = "";
        }
        if (!("x" in $$source)) {
            this["x"] = 0;
        }
        if (!("y" in $$source)) {
            this["y"] = 0;
        }
        if (!("width" in $$source)) {
            this["width"] = 0;
        }
        if (!("height" in $$source)) {
            this["height"] = 0;
        }
        if (!("primary" in $$source)) {
            this["primary"] = false;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ScreenInfo instance from a string or object.
     */
    static createFrom($$source: any = {}): ScreenInfo {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ScreenInfo($$parsedSource as Partial<ScreenInfo>);
    }
}

/**
 * Service manages windowing, dialogs, and other visual elements.
 * It is the primary interface for interacting with the UI.
 */
export class Service {

    /** Creates a new Service instance. */
    constructor($$source: Partial<Service> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Service instance from a string or object.
     */
    static createFrom($$source: any = {}): Service {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Service($$parsedSource as Partial<Service>);
    }
}

/**
 * SnapPosition represents positions for snapping windows.
 */
export enum SnapPosition {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    SnapLeft = "left",
    SnapRight = "right",
    SnapTop = "top",
    SnapBottom = "bottom",
    SnapTopLeft = "top-left",
    SnapTopRight = "top-right",
    SnapBottomLeft = "bottom-left",
    SnapBottomRight = "bottom-right",
    SnapCenter = "center",
};

/**
 * ThemeInfo contains information about the current theme.
 */
export class ThemeInfo {
    "isDark": boolean;

    /**
     * "dark" or "light"
     */
    "theme": string;

    /**
     * Whether following system theme
     */
    "system": boolean;

    /** Creates a new ThemeInfo instance. */
    constructor($$source: Partial<ThemeInfo> = {}) {
        if (!("isDark" in $$source)) {
            this["isDark"] = false;
        }
        if (!("theme" in $$source)) {
            this["theme"] = "";
        }
        if (!("system" in $$source)) {
            this["system"] = false;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ThemeInfo instance from a string or object.
     */
    static createFrom($$source: any = {}): ThemeInfo {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ThemeInfo($$parsedSource as Partial<ThemeInfo>);
    }
}

/**
 * TileMode represents different tiling arrangements.
 */
export enum TileMode {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    TileModeLeft = "left",
    TileModeRight = "right",
    TileModeTop = "top",
    TileModeBottom = "bottom",
    TileModeTopLeft = "top-left",
    TileModeTopRight = "top-right",
    TileModeBottomLeft = "bottom-left",
    TileModeBottomRight = "bottom-right",
    TileModeGrid = "grid",
};

/**
 * TrayMenuItem represents a menu item for the system tray.
 */
export class TrayMenuItem {
    "label": string;

    /**
     * "normal", "separator", "checkbox", "radio"
     */
    "type"?: string;

    /**
     * for checkbox/radio items
     */
    "checked"?: boolean;
    "disabled"?: boolean;
    "tooltip"?: string;
    "submenu"?: TrayMenuItem[];

    /**
     * ID for callback
     */
    "actionId"?: string;

    /** Creates a new TrayMenuItem instance. */
    constructor($$source: Partial<TrayMenuItem> = {}) {
        if (!("label" in $$source)) {
            this["label"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new TrayMenuItem instance from a string or object.
     */
    static createFrom($$source: any = {}): TrayMenuItem {
        const $$createField5_0 = $$createType6;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("submenu" in $$parsedSource) {
            $$parsedSource["submenu"] = $$createField5_0($$parsedSource["submenu"]);
        }
        return new TrayMenuItem($$parsedSource as Partial<TrayMenuItem>);
    }
}

/**
 * WSEventManager manages WebSocket connections and event subscriptions.
 */
export class WSEventManager {

    /** Creates a new WSEventManager instance. */
    constructor($$source: Partial<WSEventManager> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new WSEventManager instance from a string or object.
     */
    static createFrom($$source: any = {}): WSEventManager {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new WSEventManager($$parsedSource as Partial<WSEventManager>);
    }
}

export const Window = application$0.WebviewWindowOptions;
export type Window = application$0.WebviewWindowOptions;

/**
 * WindowInfo contains information about a window for MCP.
 */
export class WindowInfo {
    "name": string;
    "x": number;
    "y": number;
    "width": number;
    "height": number;
    "maximized": boolean;

    /** Creates a new WindowInfo instance. */
    constructor($$source: Partial<WindowInfo> = {}) {
        if (!("name" in $$source)) {
            this["name"] = "";
        }
        if (!("x" in $$source)) {
            this["x"] = 0;
        }
        if (!("y" in $$source)) {
            this["y"] = 0;
        }
        if (!("width" in $$source)) {
            this["width"] = 0;
        }
        if (!("height" in $$source)) {
            this["height"] = 0;
        }
        if (!("maximized" in $$source)) {
            this["maximized"] = false;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new WindowInfo instance from a string or object.
     */
    static createFrom($$source: any = {}): WindowInfo {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new WindowInfo($$parsedSource as Partial<WindowInfo>);
    }
}

export type WindowOption = any;

/**
 * WindowState holds the persisted state of a window.
 */
export class WindowState {
    "x": number;
    "y": number;
    "width": number;
    "height": number;
    "maximized": boolean;

    /**
     * Screen identifier for multi-monitor
     */
    "screen"?: string;

    /**
     * Last URL/route
     */
    "url"?: string;
    "updatedAt": number;

    /** Creates a new WindowState instance. */
    constructor($$source: Partial<WindowState> = {}) {
        if (!("x" in $$source)) {
            this["x"] = 0;
        }
        if (!("y" in $$source)) {
            this["y"] = 0;
        }
        if (!("width" in $$source)) {
            this["width"] = 0;
        }
        if (!("height" in $$source)) {
            this["height"] = 0;
        }
        if (!("maximized" in $$source)) {
            this["maximized"] = false;
        }
        if (!("updatedAt" in $$source)) {
            this["updatedAt"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new WindowState instance from a string or object.
     */
    static createFrom($$source: any = {}): WindowState {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new WindowState($$parsedSource as Partial<WindowState>);
    }
}

/**
 * WorkArea represents usable screen space (excluding dock, menubar, etc).
 */
export class WorkArea {
    "screenId": string;
    "x": number;
    "y": number;
    "width": number;
    "height": number;

    /** Creates a new WorkArea instance. */
    constructor($$source: Partial<WorkArea> = {}) {
        if (!("screenId" in $$source)) {
            this["screenId"] = "";
        }
        if (!("x" in $$source)) {
            this["x"] = 0;
        }
        if (!("y" in $$source)) {
            this["y"] = 0;
        }
        if (!("width" in $$source)) {
            this["width"] = 0;
        }
        if (!("height" in $$source)) {
            this["height"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new WorkArea instance from a string or object.
     */
    static createFrom($$source: any = {}): WorkArea {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new WorkArea($$parsedSource as Partial<WorkArea>);
    }
}

/**
 * WorkflowType represents predefined workflow layouts.
 */
export enum WorkflowType {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    WorkflowCoding = "coding",
    WorkflowDebugging = "debugging",
    WorkflowPresenting = "presenting",
    WorkflowSideBySide = "side-by-side",
};

// Private type creation functions
const $$createType0 = $Create.Array($Create.Any);
const $$createType1 = WindowState.createFrom;
const $$createType2 = $Create.Map($Create.Any, $$createType1);
const $$createType3 = FileFilter.createFrom;
const $$createType4 = $Create.Array($$createType3);
const $$createType5 = TrayMenuItem.createFrom;
const $$createType6 = $Create.Array($$createType5);
