// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import { Create as $Create } from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as render$0 from "./render/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as template$0 from "../../../html/template/models.js";

/**
 * Engine is the framework's instance, it contains the muxer, middleware and configuration settings.
 * Create an instance of Engine, by using New() or Default()
 */
export class Engine {
    "Handlers": HandlersChain;

    /**
     * RedirectTrailingSlash enables automatic redirection if the current route can't be matched but a
     * handler for the path with (without) the trailing slash exists.
     * For example if /foo/ is requested but a route only exists for /foo, the
     * client is redirected to /foo with http status code 301 for GET requests
     * and 307 for all other request methods.
     */
    "RedirectTrailingSlash": boolean;

    /**
     * RedirectFixedPath if enabled, the router tries to fix the current request path, if no
     * handle is registered for it.
     * First superfluous path elements like ../ or // are removed.
     * Afterwards the router does a case-insensitive lookup of the cleaned path.
     * If a handle can be found for this route, the router makes a redirection
     * to the corrected path with status code 301 for GET requests and 307 for
     * all other request methods.
     * For example /FOO and /..//Foo could be redirected to /foo.
     * RedirectTrailingSlash is independent of this option.
     */
    "RedirectFixedPath": boolean;

    /**
     * HandleMethodNotAllowed if enabled, the router checks if another method is allowed for the
     * current route, if the current request can not be routed.
     * If this is the case, the request is answered with 'Method Not Allowed'
     * and HTTP status code 405.
     * If no other Method is allowed, the request is delegated to the NotFound
     * handler.
     */
    "HandleMethodNotAllowed": boolean;

    /**
     * ForwardedByClientIP if enabled, client IP will be parsed from the request's headers that
     * match those stored at `(*gin.Engine).RemoteIPHeaders`. If no IP was
     * fetched, it falls back to the IP obtained from
     * `(*gin.Context).Request.RemoteAddr`.
     */
    "ForwardedByClientIP": boolean;

    /**
     * AppEngine was deprecated.
     * Deprecated: USE `TrustedPlatform` WITH VALUE `gin.PlatformGoogleAppEngine` INSTEAD
     * #726 #755 If enabled, it will trust some headers starting with
     * 'X-AppEngine...' for better integration with that PaaS.
     */
    "AppEngine": boolean;

    /**
     * UseRawPath if enabled, the url.RawPath will be used to find parameters.
     */
    "UseRawPath": boolean;

    /**
     * UnescapePathValues if true, the path value will be unescaped.
     * If UseRawPath is false (by default), the UnescapePathValues effectively is true,
     * as url.Path gonna be used, which is already unescaped.
     */
    "UnescapePathValues": boolean;

    /**
     * RemoveExtraSlash a parameter can be parsed from the URL even with extra slashes.
     * See the PR #1817 and issue #1644
     */
    "RemoveExtraSlash": boolean;

    /**
     * RemoteIPHeaders list of headers used to obtain the client IP when
     * `(*gin.Engine).ForwardedByClientIP` is `true` and
     * `(*gin.Context).Request.RemoteAddr` is matched by at least one of the
     * network origins of list defined by `(*gin.Engine).SetTrustedProxies()`.
     */
    "RemoteIPHeaders": string[];

    /**
     * TrustedPlatform if set to a constant of value gin.Platform*, trusts the headers set by
     * that platform, for example to determine the client IP
     */
    "TrustedPlatform": string;

    /**
     * MaxMultipartMemory value of 'maxMemory' param that is given to http.Request's ParseMultipartForm
     * method call.
     */
    "MaxMultipartMemory": number;

    /**
     * UseH2C enable h2c support.
     */
    "UseH2C": boolean;

    /**
     * ContextWithFallback enable fallback Context.Deadline(), Context.Done(), Context.Err() and Context.Value() when Context.Request.Context() is not nil.
     */
    "ContextWithFallback": boolean;
    "HTMLRender": render$0.HTMLRender;
    "FuncMap": template$0.FuncMap;

    /** Creates a new Engine instance. */
    constructor($$source: Partial<Engine> = {}) {
        if (!("Handlers" in $$source)) {
            this["Handlers"] = [];
        }
        if (!("RedirectTrailingSlash" in $$source)) {
            this["RedirectTrailingSlash"] = false;
        }
        if (!("RedirectFixedPath" in $$source)) {
            this["RedirectFixedPath"] = false;
        }
        if (!("HandleMethodNotAllowed" in $$source)) {
            this["HandleMethodNotAllowed"] = false;
        }
        if (!("ForwardedByClientIP" in $$source)) {
            this["ForwardedByClientIP"] = false;
        }
        if (!("AppEngine" in $$source)) {
            this["AppEngine"] = false;
        }
        if (!("UseRawPath" in $$source)) {
            this["UseRawPath"] = false;
        }
        if (!("UnescapePathValues" in $$source)) {
            this["UnescapePathValues"] = false;
        }
        if (!("RemoveExtraSlash" in $$source)) {
            this["RemoveExtraSlash"] = false;
        }
        if (!("RemoteIPHeaders" in $$source)) {
            this["RemoteIPHeaders"] = [];
        }
        if (!("TrustedPlatform" in $$source)) {
            this["TrustedPlatform"] = "";
        }
        if (!("MaxMultipartMemory" in $$source)) {
            this["MaxMultipartMemory"] = 0;
        }
        if (!("UseH2C" in $$source)) {
            this["UseH2C"] = false;
        }
        if (!("ContextWithFallback" in $$source)) {
            this["ContextWithFallback"] = false;
        }
        if (!("HTMLRender" in $$source)) {
            this["HTMLRender"] = null;
        }
        if (!("FuncMap" in $$source)) {
            this["FuncMap"] = {};
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Engine instance from a string or object.
     */
    static createFrom($$source: any = {}): Engine {
        const $$createField0_0 = $$createType0;
        const $$createField9_0 = $$createType2;
        const $$createField15_0 = $$createType3;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Handlers" in $$parsedSource) {
            $$parsedSource["Handlers"] = $$createField0_0($$parsedSource["Handlers"]);
        }
        if ("RemoteIPHeaders" in $$parsedSource) {
            $$parsedSource["RemoteIPHeaders"] = $$createField9_0($$parsedSource["RemoteIPHeaders"]);
        }
        if ("FuncMap" in $$parsedSource) {
            $$parsedSource["FuncMap"] = $$createField15_0($$parsedSource["FuncMap"]);
        }
        return new Engine($$parsedSource as Partial<Engine>);
    }
}

/**
 * HandlerFunc defines the handler used by gin middleware as return value.
 */
export type HandlerFunc = any;

/**
 * HandlersChain defines a HandlerFunc slice.
 */
export type HandlersChain = HandlerFunc[];

// Private type creation functions
var $$createType0 = (function $$initCreateType0(...args: any[]): any {
    if ($$createType0 === $$initCreateType0) {
        $$createType0 = $$createType1;
    }
    return $$createType0(...args);
});
const $$createType1 = $Create.Array($Create.Any);
const $$createType2 = $Create.Array($Create.Any);
var $$createType3 = (function $$initCreateType3(...args: any[]): any {
    if ($$createType3 === $$initCreateType3) {
        $$createType3 = $$createType4;
    }
    return $$createType3(...args);
});
const $$createType4 = $Create.Map($Create.Any, $Create.Any);
